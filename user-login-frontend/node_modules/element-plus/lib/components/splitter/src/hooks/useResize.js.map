{"version":3,"file":"useResize.js","sources":["../../../../../../../packages/components/splitter/src/hooks/useResize.ts"],"sourcesContent":["import { computed, ref, watch } from 'vue'\nimport { getPct, getPx, isPct, isPx } from './useSize'\nimport { NOOP } from '@element-plus/utils'\n\nimport type { ComputedRef, Ref } from 'vue'\nimport type { PanelItemState } from '../type'\n\nexport function useResize(\n  panels: Ref<PanelItemState[]>,\n  containerSize: ComputedRef<number>,\n  pxSizes: ComputedRef<number[]>,\n  lazy: Ref<boolean>\n) {\n  const ptg2px = (ptg: number) => ptg * containerSize.value || 0\n\n  function getLimitSize(\n    str: string | number | undefined,\n    defaultLimit: number\n  ) {\n    if (isPct(str)) {\n      return ptg2px(getPct(str))\n    } else if (isPx(str)) {\n      return getPx(str)\n    }\n    return str ?? defaultLimit\n  }\n\n  const lazyOffset = ref(0)\n  const movingIndex = ref<{\n    index: number\n    confirmed: boolean\n  } | null>(null)\n\n  let cachePxSizes: number[] = []\n  let updatePanelSizes = NOOP\n\n  const limitSizes = computed(() =>\n    panels.value.map((item) => [item.min, item.max])\n  )\n\n  watch(lazy, () => {\n    if (lazyOffset.value) {\n      const mouseup = new MouseEvent('mouseup', { bubbles: true })\n      window.dispatchEvent(mouseup)\n    }\n  })\n\n  const onMoveStart = (index: number) => {\n    lazyOffset.value = 0\n    movingIndex.value = { index, confirmed: false }\n    cachePxSizes = pxSizes.value\n  }\n\n  const onMoving = (index: number, offset: number) => {\n    let confirmedIndex: number | null = null\n\n    // When overlapping, find the nearest draggable index\n    if ((!movingIndex.value || !movingIndex.value.confirmed) && offset !== 0) {\n      if (offset > 0) {\n        confirmedIndex = index\n        movingIndex.value = { index, confirmed: true }\n      } else {\n        for (let i = index; i >= 0; i -= 1) {\n          if (cachePxSizes[i]! > 0) {\n            confirmedIndex = i\n            movingIndex.value = { index: i, confirmed: true }\n            break\n          }\n        }\n      }\n    }\n    const mergedIndex = confirmedIndex ?? movingIndex.value?.index ?? index\n\n    const numSizes = [...cachePxSizes]\n    const nextIndex = mergedIndex + 1\n\n    // Handle the maximum and minimum edge cases\n    const startMinSize = getLimitSize(limitSizes.value[mergedIndex]![0], 0)\n    const endMinSize = getLimitSize(limitSizes.value[nextIndex]![0], 0)\n    const startMaxSize = getLimitSize(\n      limitSizes.value[mergedIndex]![1],\n      containerSize.value || 0\n    )\n    const endMaxSize = getLimitSize(\n      limitSizes.value[nextIndex]![1],\n      containerSize.value || 0\n    )\n\n    let mergedOffset = offset\n\n    if (numSizes[mergedIndex]! + mergedOffset < startMinSize) {\n      mergedOffset = startMinSize - numSizes[mergedIndex]!\n    }\n    if (numSizes[nextIndex]! - mergedOffset < endMinSize) {\n      mergedOffset = numSizes[nextIndex]! - endMinSize\n    }\n    if (numSizes[mergedIndex]! + mergedOffset > startMaxSize) {\n      mergedOffset = startMaxSize - numSizes[mergedIndex]!\n    }\n    if (numSizes[nextIndex]! - mergedOffset > endMaxSize) {\n      mergedOffset = numSizes[nextIndex]! - endMaxSize\n    }\n\n    numSizes[mergedIndex]! += mergedOffset\n    numSizes[nextIndex]! -= mergedOffset\n    lazyOffset.value = mergedOffset\n\n    updatePanelSizes = () => {\n      panels.value.forEach((panel, index) => {\n        panel.size = numSizes[index]\n      })\n      updatePanelSizes = NOOP\n    }\n\n    if (!lazy.value) {\n      updatePanelSizes()\n    }\n  }\n\n  const onMoveEnd = () => {\n    if (lazy.value) {\n      updatePanelSizes()\n    }\n\n    lazyOffset.value = 0\n    movingIndex.value = null\n    cachePxSizes = []\n  }\n\n  const cacheCollapsedSize: number[] = []\n  const onCollapse = (index: number, type: 'start' | 'end') => {\n    if (!cacheCollapsedSize.length) {\n      cacheCollapsedSize.push(...pxSizes.value)\n    }\n\n    const currentSizes = pxSizes.value\n\n    const currentIndex = type === 'start' ? index : index + 1\n    const targetIndex = type === 'start' ? index + 1 : index\n\n    const currentSize = currentSizes[currentIndex]\n    const targetSize = currentSizes[targetIndex]\n\n    if (currentSize !== 0 && targetSize !== 0) {\n      currentSizes[currentIndex] = 0\n      currentSizes[targetIndex]! += currentSize\n      cacheCollapsedSize[index] = currentSize\n    } else {\n      const totalSize = currentSize + targetSize\n\n      const targetCacheCollapsedSize = cacheCollapsedSize[index]\n      const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize\n\n      currentSizes[targetIndex] = targetCacheCollapsedSize\n      currentSizes[currentIndex] = currentCacheCollapsedSize\n    }\n\n    panels.value.forEach((panel, index) => {\n      panel.size = currentSizes[index]\n    })\n  }\n\n  return {\n    lazyOffset,\n    onMoveStart,\n    onMoving,\n    onMoveEnd,\n    movingIndex,\n    onCollapse,\n  }\n}\n"],"names":["isPct","getPct","isPx","getPx","ref","NOOP","computed","watch","index"],"mappings":"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"}