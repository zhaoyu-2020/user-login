import { timeSelectProps } from './time-select.mjs';
import { defineComponent, ref, computed, createBlock, openBlock, unref, withCtx, createElementBlock, Fragment, renderList, createCommentVNode, normalizeClass, resolveDynamicComponent } from 'vue';
import dayjs from 'dayjs';
import customParseFormat from 'dayjs/plugin/customParseFormat.js';
import { ElSelect } from '../../select/index.mjs';
import { ElIcon } from '../../icon/index.mjs';
import { parseTime, formatTime, compareTime, nextTime } from './utils.mjs';
import { CHANGE_EVENT, UPDATE_MODEL_EVENT } from '../../../constants/event.mjs';
import { useNamespace } from '../../../hooks/use-namespace/index.mjs';
import { useFormDisabled } from '../../form/src/hooks/use-form-common-props.mjs';
import { useLocale } from '../../../hooks/use-locale/index.mjs';

var _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "ElTimeSelect"
  },
  __name: "time-select",
  props: timeSelectProps,
  emits: [CHANGE_EVENT, "blur", "focus", "clear", UPDATE_MODEL_EVENT],
  setup(__props, { expose: __expose }) {
    dayjs.extend(customParseFormat);
    const { Option: ElOption } = ElSelect;
    const props = __props;
    const nsInput = useNamespace("input");
    const select = ref();
    const _disabled = useFormDisabled();
    const { lang } = useLocale();
    const value = computed(() => props.modelValue);
    const start = computed(() => {
      const time = parseTime(props.start);
      return time ? formatTime(time) : null;
    });
    const end = computed(() => {
      const time = parseTime(props.end);
      return time ? formatTime(time) : null;
    });
    const step = computed(() => {
      const time = parseTime(props.step);
      return time ? formatTime(time) : null;
    });
    const minTime = computed(() => {
      const time = parseTime(props.minTime || "");
      return time ? formatTime(time) : null;
    });
    const maxTime = computed(() => {
      const time = parseTime(props.maxTime || "");
      return time ? formatTime(time) : null;
    });
    const items = computed(() => {
      var _a;
      const result = [];
      const push = (formattedValue, rawValue) => {
        result.push({
          value: formattedValue,
          disabled: compareTime(rawValue, minTime.value || "-1:-1") <= 0 || compareTime(rawValue, maxTime.value || "100:100") >= 0
        });
      };
      if (props.start && props.end && props.step) {
        let current = start.value;
        let currentTime;
        while (current && end.value && compareTime(current, end.value) <= 0) {
          currentTime = dayjs(current, "HH:mm").locale(lang.value).format(props.format);
          push(currentTime, current);
          current = nextTime(current, step.value);
        }
        if (props.includeEndTime && end.value && ((_a = result[result.length - 1]) == null ? void 0 : _a.value) !== end.value) {
          const formattedValue = dayjs(end.value, "HH:mm").locale(lang.value).format(props.format);
          push(formattedValue, end.value);
        }
      }
      return result;
    });
    const blur = () => {
      var _a, _b;
      (_b = (_a = select.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
    };
    const focus = () => {
      var _a, _b;
      (_b = (_a = select.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
    };
    __expose({
      /**
       * @description blur the Input component
       */
      blur,
      /**
       * @description focus the Input component
       */
      focus
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(ElSelect), {
        ref_key: "select",
        ref: select,
        "model-value": value.value,
        disabled: unref(_disabled),
        clearable: __props.clearable,
        "clear-icon": __props.clearIcon,
        size: __props.size,
        effect: __props.effect,
        placeholder: __props.placeholder,
        "default-first-option": "",
        filterable: __props.editable,
        "empty-values": __props.emptyValues,
        "value-on-clear": __props.valueOnClear,
        "popper-class": __props.popperClass,
        "popper-style": __props.popperStyle,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = (event) => _ctx.$emit(unref(UPDATE_MODEL_EVENT), event)),
        onChange: _cache[1] || (_cache[1] = (event) => _ctx.$emit(unref(CHANGE_EVENT), event)),
        onBlur: _cache[2] || (_cache[2] = (event) => _ctx.$emit("blur", event)),
        onFocus: _cache[3] || (_cache[3] = (event) => _ctx.$emit("focus", event)),
        onClear: _cache[4] || (_cache[4] = () => _ctx.$emit("clear"))
      }, {
        prefix: withCtx(() => [
          __props.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
            key: 0,
            class: normalizeClass(unref(nsInput).e("prefix-icon"))
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(__props.prefixIcon)))
            ]),
            _: 1
            /* STABLE */
          }, 8, ["class"])) : createCommentVNode("v-if", true)
        ]),
        default: withCtx(() => [
          (openBlock(true), createElementBlock(
            Fragment,
            null,
            renderList(items.value, (item) => {
              return openBlock(), createBlock(unref(ElOption), {
                key: item.value,
                label: item.value,
                value: item.value,
                disabled: item.disabled
              }, null, 8, ["label", "value", "disabled"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ]),
        _: 1
        /* STABLE */
      }, 8, ["model-value", "disabled", "clearable", "clear-icon", "size", "effect", "placeholder", "filterable", "empty-values", "value-on-clear", "popper-class", "popper-style"]);
    };
  }
});

export { _sfc_main as default };
//# sourceMappingURL=time-select.vue2.mjs.map
